// +build ignore

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"golang.org/x/tools/go/packages"
	"gopkg.in/yaml.v2"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
)

var errContext = `
var (
	allList  = []*Entity{}
	EVOPathList = [][]*Entity{}
)
`

type all struct {
	EntityList []*entity `yaml:"entity,flow"`
}

type entity struct {
	Key   string   `yaml:"key"`
	Name  string   `yaml:"name"`
	CName string   `yaml:"cname"`
	Phase string   `yaml:"phase"`
	EvoLock string `yaml:"evoLock"`
	Evo   string   `yaml:"evo"`
	Next  []string `yaml:"next,flow"`
	p     []string
	n     []string
}

var notExistEntity = &entity{}

type BytesBuffer struct {
	*bytes.Buffer
}

func (buf *BytesBuffer) writeStringf(format string, v ...interface{}) {
	_, _ = fmt.Fprintf(buf, format, v...)
}

func (buf *BytesBuffer) WriteString(s string) {
	buf.Buffer.WriteString(s)
}

func findEntity(name string, all *all) *entity {
	for _, entity := range all.EntityList {
		if entity.Name == name || entity.CName == name {
			return entity
		}
	}
	return notExistEntity
}

func main() {
	dir := "."
	if args := flag.Args(); len(args) == 1 {
		dir = args[0]
	} else if len(args) > 1 {
		log.Fatalf("only one directory at a time")
	}
	//tmppkg := flag.String("pkg", "tmptmp", "")
	//flag.Parse()
	//fmt.Println(*tmppkg)

	cfg := &packages.Config{
		Mode: packages.LoadSyntax,
		// in a separate pass? For later.
		Tests:      false,
		BuildFlags: []string{fmt.Sprintf("-tags=%s", strings.Join([]string{}, " "))},
	}
	pkgs, err := packages.Load(cfg, flag.Args()...)
	if err != nil {
		log.Fatal(err)
	}
	if len(pkgs) != 1 {
		log.Fatalf("error: %d packages found", len(pkgs))
	}
	pkg := pkgs[0].Name
	//fmt.Println(pkg)
	buf := &BytesBuffer{
		&bytes.Buffer{},
	}
	//buf := &bytes.Buffer{}

	buf.WriteString("// Code generated by go:generate; DO NOT EDIT.\n")
	buf.writeStringf("package %v\n", pkg)
	entityTypeStr := `
import "errors"
type Entity struct {
	Key string
	Name string
	CName string
	Phase string
	EvoLock string
	Evo string
	P []string
	N []string
}
var NotExistEntityError = errors.New("Entity Not Find")

func FindEntityByName(name string) (*Entity, error) {
	for _, entity := range allList {
		if entity.Name == name || entity.CName == name {
			return entity, nil
		}
	}
	return &Entity{}, NotExistEntityError
}
	`
	buf.WriteString(entityTypeStr)
	buf.WriteString("\n")
	defer func() {
		formattedBuf, err := format.Source(buf.Bytes())
		if err != nil {
			fmt.Println(string(buf.Bytes()))
			log.Printf("Formatting code failed: %v", err)
			os.Exit(1)
		}
		outfileName := "data.go"
		outputPath := filepath.Join(dir, outfileName)
		if err = ioutil.WriteFile(outputPath, formattedBuf, 0644); err != nil {
			log.Printf("Failed to write to '%s': %v", outfileName, err)
		}
	}()

	context, err := ioutil.ReadFile("./evo-data.yml")
	if err != nil {
		fmt.Println("读取配置文件出错")
		buf.WriteString(errContext)
		buf.WriteString("// 读取配置文件出错\n")
		return
	}

	all := &all{}

	err = yaml.Unmarshal(context, all)
	if err != nil {
		fmt.Printf("解析配置文件出错:%v\n", err)
		buf.WriteString(errContext)
		buf.writeStringf("/* 解析配置文件出错: %v*/\n", err)
		return
	}

	var allKeys []string
	entityMap := make(map[string]*entity)

	for _, entity := range all.EntityList {
		allKeys = append(allKeys, entity.Key)
		for _, sName := range entity.Next {
			sEntity := findEntity(sName, all)
			if sEntity == notExistEntity {
				fmt.Printf("Not Sub Exist Entity: %v(%v): %v\n", entity.Name, entity.CName, sName)
			} else {
				//sEntity.p = append(sEntity.p, fmt.Sprintf(`"%v"`, entity.Key))
				//entity.n = append(entity.n, fmt.Sprintf(`"%v"`, sEntity.Key))
				sEntity.p = append(sEntity.p, entity.Key)
				entity.n = append(entity.n, sEntity.Key)
			}
		}
		entityMap[entity.Key] = entity
	}

	var rootList []*entity
	var rootKeys []string

	for _, entity := range all.EntityList {
		if len(entity.p) > 0 && entity.p[0] == "root" {
			rootList = append(rootList, entity)
			rootKeys = append(rootKeys, entity.Key)
		}
	}

	buf.WriteString("var (\n")
	buf.writeStringf("RootList=[]*Entity{%s}\n", strings.Join(rootKeys, ","))
	buf.writeStringf("allList=[]*Entity{%s}\n", strings.Join(allKeys, ","))
	buf.WriteString("EVOPathList=[][]*Entity{\n")

	for _, entity := range rootList {
		evoPathList := genEVOPath(entity, entityMap)
		pathKeyMap := make(map[string]int)
		for _, evoPath := range evoPathList {
			//fmt.Println("==============")
			//fmt.Println(evoPath)
			//fmt.Println("--------------")
			for idx := range evoPath {
				if idx > 0 {
					path := evoPath[:idx+1]
					pathKey := strings.Join(path, ",")
					_, ok := pathKeyMap[pathKey]
					if !ok {
						pathKeyMap[pathKey] = 1
						buf.writeStringf("{%v},\n", strings.Join(path, ","))
					}
				}
			}
		}
	}
	buf.WriteString("}\n")

	buf.WriteString("EntityMap=map[string]*Entity{\n")
	for _, entity := range all.EntityList {
		buf.writeStringf(`"%v":%v,`, entity.Key, entity.Key)
	}
	buf.WriteString("}\n")

	templateStr := `Key:"%v",
		Name:"%v",
		CName:"%v",
		Phase:"%v",
		EvoLock:"%v",
		Evo:"%v",
		P: []string{%v},
		N: []string{%v},
	`
	for _, entity := range all.EntityList {
		buf.writeStringf("%v=&Entity{\n", entity.Key)
		var pKeys []string
		for _, key := range entity.p {
			pKeys = append(pKeys, fmt.Sprintf(`"%v"`, key))
		}
		var nKeys []string
		for _, key := range entity.n {
			nKeys = append(nKeys, fmt.Sprintf(`"%v"`, key))
		}
		buf.writeStringf(templateStr, entity.Key, entity.Name, entity.CName, entity.Phase, entity.EvoLock,
			entity.Evo, strings.Join(pKeys, ","), strings.Join(nKeys, ","))
		buf.WriteString("}\n")
	}
	buf.WriteString(")\n")
}

func genEVOPath(entity *entity, entityMap map[string]*entity) [][]string {
	var evoPathList [][]string
	evoPath := []string{entity.Key}
	if len(entity.n) > 0 {
		for _, key := range entity.n {
			subEVOPathList := genEVOPath(entityMap[key], entityMap)
			for _, subEVOPath := range subEVOPathList {
				newEvoPath := append(evoPath, subEVOPath...)
				evoPathList = append(evoPathList, newEvoPath)
			}
		}
	} else {
		evoPathList = append(evoPathList, evoPath)
	}
	return evoPathList
}
