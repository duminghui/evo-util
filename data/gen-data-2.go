// +build ignore

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"golang.org/x/tools/go/packages"
	"gopkg.in/yaml.v2"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

var errContext = `
var (
	allList  = []*Entity{}
	EVOPathList = [][]*EVONode{}
)
`

type all struct {
	EntityList []*entity `yaml:"entity,flow"`
}

type entity struct {
	Key     string   `yaml:"key"`
	Name    string   `yaml:"name"`
	CName   string   `yaml:"cname"`
	Phase   string   `yaml:"phase"`
	EvoLock string   `yaml:"evoLock"`
	Evo     string   `yaml:"evo"`
	Next    []string `yaml:"next,flow"`
	p       []pOrdInfo
	n       []nOrdInfo
}

type pOrdInfo struct {
	pKey string
	ord  int
}

type pOrdInfoList []pOrdInfo

func (p pOrdInfoList) Len() int {
	return len(p)
}

func (p pOrdInfoList) Less(i, j int) bool {
	return p[i].ord < p[j].ord
}

func (p pOrdInfoList) Swap(i, j int) {
	p[i], p[j] = p[j], p[i]
}

type nOrdInfo struct {
	nKey string
	ord  int
}

type nodeInfo struct {
	pKey string
	nOrd int
}

var notExistEntity = &entity{}

type BytesBuffer struct {
	*bytes.Buffer
}

func (buf *BytesBuffer) writeStringf(format string, v ...interface{}) {
	_, _ = fmt.Fprintf(buf, format, v...)
}

func (buf *BytesBuffer) WriteString(s string) {
	buf.Buffer.WriteString(s)
}

func findEntity(name string, all *all) *entity {
	for _, entity := range all.EntityList {
		if entity.Name == name || entity.CName == name {
			return entity
		}
	}
	return notExistEntity
}

func main() {
	dir := "."
	if args := flag.Args(); len(args) == 1 {
		dir = args[0]
	} else if len(args) > 1 {
		log.Fatalf("only one directory at a time")
	}
	//tmppkg := flag.String("pkg", "tmptmp", "")
	//flag.Parse()
	//fmt.Println(*tmppkg)

	cfg := &packages.Config{
		Mode: packages.LoadSyntax,
		// in a separate pass? For later.
		Tests:      false,
		BuildFlags: []string{fmt.Sprintf("-tags=%s", strings.Join([]string{}, " "))},
	}
	pkgs, err := packages.Load(cfg, flag.Args()...)
	if err != nil {
		log.Fatal(err)
	}
	if len(pkgs) != 1 {
		log.Fatalf("error: %d packages found", len(pkgs))
	}
	pkg := pkgs[0].Name
	//fmt.Println(pkg)
	buf := &BytesBuffer{
		&bytes.Buffer{},
	}
	//buf := &bytes.Buffer{}

	buf.WriteString("// Code generated by go:generate; DO NOT EDIT.\n")
	buf.writeStringf("package %v\n", pkg)
	defer func() {
		formattedBuf, err := format.Source(buf.Bytes())
		if err != nil {
			fmt.Println(string(buf.Bytes()))
			log.Printf("Formatting code failed: %v", err)
			os.Exit(1)
		}
		outfileName := "data.go"
		outputPath := filepath.Join(dir, outfileName)
		if err = ioutil.WriteFile(outputPath, formattedBuf, 0644); err != nil {
			log.Printf("Failed to write to '%s': %v", outfileName, err)
		}
	}()

	context, err := ioutil.ReadFile("./evo-data.yml")
	if err != nil {
		fmt.Println("读取配置文件出错")
		buf.WriteString(errContext)
		buf.WriteString("// 读取配置文件出错\n")
		return
	}

	all := &all{}

	err = yaml.Unmarshal(context, all)
	if err != nil {
		fmt.Printf("解析配置文件出错:%v\n", err)
		buf.WriteString(errContext)
		buf.writeStringf("/* 解析配置文件出错: %v*/\n", err)
		return
	}

	var allKeys []string
	entityMap := make(map[string]*entity)

	for _, entity := range all.EntityList[1:] {
		entityMap[entity.Key] = entity
		allKeys = append(allKeys, entity.Key)
		for _, sName := range entity.Next {
			sEntity := findEntity(sName, all)
			if sEntity == notExistEntity {
				fmt.Printf("Not Sub Exist Entity: %v(%v): %v\n", entity.Name, entity.CName, sName)
			} else {
				ord := getOrdInParentByName(sName, entity.Next)
				sEntity.p = append(sEntity.p, pOrdInfo{entity.Key, ord})
				entity.n = append(entity.n, nOrdInfo{sEntity.Key, ord})
			}
		}
		//fmt.Printf("%+v\n", entity)
	}

	var rootList []*entity
	var rootKeys []string

	for _, entity := range all.EntityList[1:] {
		if len(entity.p) == 0 {
			rootList = append(rootList, entity)
			rootKeys = append(rootKeys, entity.Key)
		} else {
			sort.Sort(pOrdInfoList(entity.p))
		}
	}

	buf.WriteString("var (\n")
	buf.writeStringf("RootList=[]*Entity{%s}\n", strings.Join(rootKeys, ","))
	buf.writeStringf("AllList=[]*Entity{%s}\n", strings.Join(allKeys, ","))
	// 2270, 3383
	buf.WriteString("EVOPathList=[][]*EVONode{\n")

	for _, entity := range rootList {
		pathKeyMap := make(map[string]int)
		evoPathList := genEVOPath(entity, entityMap)
		for _, evoPath := range evoPathList {
			for idx := range evoPath {
				if idx > 0 {
					subPath := evoPath[:idx+1]
					var pathKeyList []string
					var nodeList []string
					subPathLen := len(subPath)
					for i, node := range subPath {
						nOrd := node.nOrd
						if i == subPathLen-1 {
							nOrd = 0
						}
						pathKeyList = append(pathKeyList, fmt.Sprintf("%v%v", node.pKey, nOrd))
						//nNodeOrd := 0
						//if i < subPathLen {
						//	nNode
						//}
						nodeStr := fmt.Sprintf(`{%v,%v}`, node.pKey, nOrd)
						nodeList = append(nodeList, nodeStr)
					}
					//{X_0_7,1},{X_1_7,1},{X_2_7,5},{X_3_18,0}
					pathKey := strings.Join(pathKeyList, "")
					_, ok := pathKeyMap[pathKey]
					if !ok {
						buf.WriteString("{")
						buf.WriteString(strings.Join(nodeList, ","))
						buf.WriteString("},\n")
						pathKeyMap[pathKey] = 1
					} else {
						pathKeyMap[pathKey] = pathKeyMap[pathKey] + 1
					}
				}
			}
		}
	}
	buf.WriteString("}\n")
	//
	buf.WriteString("EntityMap=map[string]*Entity{\n")
	for _, entity := range all.EntityList {
		buf.writeStringf(`"%v":%v,`, entity.Key, entity.Key)
	}
	buf.WriteString("}\n")

	templateStr := `Key:"%v",
		Name:"%v",
		CName:"%v",
		Phase:"%v",
		EvoLock:"%v",
		Evo:"%v",
		P: []OrdInfo{%v},
		N: []OrdInfo{%v},
	`
	for _, entity := range all.EntityList {
		buf.writeStringf("%v=&Entity{\n", entity.Key)
		var pInfos []string
		for _, p := range entity.p {
			pInfos = append(pInfos, fmt.Sprintf(`{"%v",%v}`, p.pKey, p.ord))
		}
		var nInfos []string
		for _, n := range entity.n {
			nInfos = append(nInfos, fmt.Sprintf(`{"%v",%v}`, n.nKey, n.ord))
		}
		buf.writeStringf(templateStr, entity.Key, entity.Name, entity.CName, entity.Phase, entity.EvoLock,
			entity.Evo, strings.Join(pInfos, ","), strings.Join(nInfos, ","))
		buf.WriteString("}\n")
	}
	buf.WriteString(")\n")
}

func genEVOPath(entity *entity, entityMap map[string]*entity, ) [][]nodeInfo {
	var evoPathList [][]nodeInfo
	nLen := len(entity.n)
	if nLen > 0 {
		for _, n := range entity.n {
			subEVOPathList := genEVOPath(entityMap[n.nKey], entityMap)
			for _, subEVOPath := range subEVOPathList {
				newEvoPath := append([]nodeInfo{{entity.Key, n.ord}}, subEVOPath...)
				evoPathList = append(evoPathList, newEvoPath)
			}
		}
	} else {
		evoPathList = append(evoPathList, []nodeInfo{{entity.Key, 0}})
	}
	return evoPathList
}

func getOrdInParentByName(sName string, next []string) int {
	idx := -1
	for i, n := range next {
		if sName == n {
			idx = i
			break
		}
	}
	return getOrder(idx, len(next))
}

func getOrder(atPIndex int, pChildCount int) int {
	switch fmt.Sprintf("%v_%v", pChildCount, atPIndex) {
	case "1_0":
		return 1
	case "2_0":
		return 1
	case "2_1":
		return 2
	case "3_0":
		return 2
	case "3_1":
		return 1
	case "3_2":
		return 3
	case "4_0":
		return 3
	case "4_1":
		return 1
	case "4_2":
		return 2
	case "4_3":
		return 4
	case "5_0":
		return 4
	case "5_1":
		return 2
	case "5_2":
		return 1
	case "5_3":
		return 3
	case "5_4":
		return 5
	default:
		return 0
	}
}
