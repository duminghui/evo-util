// +build ignore

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"golang.org/x/tools/go/packages"
	"gopkg.in/yaml.v2"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
)

var errContext = `
var (
	AllList  = []*Entity{}
)
`

type all struct {
	EntityList []*entity `yaml:"entity,flow"`
}

type entity struct {
	Key   string   `yaml:"key"`
	Name  string   `yaml:"name"`
	CName string   `yaml:"cname"`
	Next  []string `yaml:"next,flow"`
	p     []string
	n     []string
}

var notExistEntity = &entity{}

type BytesBuffer struct {
	*bytes.Buffer
}

func (buf *BytesBuffer) writeStringf(format string, v ...interface{}) {
	_, _ = fmt.Fprintf(buf, format, v...)
}

func (buf *BytesBuffer) WriteString(s string) {
	buf.Buffer.WriteString(s)
}

func findEntity(name string, all *all) *entity {
	for _, entity := range all.EntityList {
		if entity.Name == name || entity.CName == name {
			return entity
		}
	}
	return notExistEntity
}

func main() {
	dir := "."
	if args := flag.Args(); len(args) == 1 {
		dir = args[0]
	} else if len(args) > 1 {
		log.Fatalf("only one directory at a time")
	}
	//tmppkg := flag.String("pkg", "tmptmp", "")
	//flag.Parse()
	//fmt.Println(*tmppkg)

	cfg := &packages.Config{
		Mode: packages.LoadSyntax,
		// in a separate pass? For later.
		Tests:      false,
		BuildFlags: []string{fmt.Sprintf("-tags=%s", strings.Join([]string{}, " "))},
	}
	pkgs, err := packages.Load(cfg, flag.Args()...)
	if err != nil {
		log.Fatal(err)
	}
	if len(pkgs) != 1 {
		log.Fatalf("error: %d packages found", len(pkgs))
	}
	pkg := pkgs[0].Name
	//fmt.Println(pkg)
	buf := &BytesBuffer{
		&bytes.Buffer{},
	}
	//buf := &bytes.Buffer{}

	buf.WriteString("// Code generated by go:generate; DO NOT EDIT.\n")
	buf.writeStringf("package %v\n", pkg)
	entityTypeStr := `
import "errors"
type Entity struct {
	Key string
	Name string
	CName string
	P []string
	N []string
}
var NotExistEntityError = errors.New("Entity Not Find")

func FindEntityByName(name string) (*Entity, error) {
	for _, entity := range allList {
		if entity.Name == name || entity.CName == name {
			return entity, nil
		}
	}
	return &Entity{}, NotExistEntityError
}
	`
	buf.WriteString(entityTypeStr)
	buf.WriteString("\n")

	defer func() {
		//fmt.Println(string(buf.Bytes()))
		formattedBuf, err := format.Source(buf.Bytes())
		if err != nil {
			log.Printf("Formatting code failed: %v", err)
			os.Exit(1)
		}
		outfileName := "data.go"
		outputPath := filepath.Join(dir, outfileName)
		if err = ioutil.WriteFile(outputPath, formattedBuf, 0644); err != nil {
			log.Printf("Failed to write to '%s': %v", outfileName, err)
		}
	}()

	context, err := ioutil.ReadFile("./evo-data.yml")
	if err != nil {
		fmt.Println("读取配置文件出错")
		buf.WriteString(errContext)
		buf.WriteString("// 读取配置文件出错\n")
		return
	}

	all := &all{}

	err = yaml.Unmarshal(context, all)
	if err != nil {
		fmt.Printf("解析配置文件出错:%v\n", err)
		buf.WriteString(errContext)
		buf.writeStringf("// 解析配置文件出错: %v\n", err)
		return
	}

	var allKeys []string

	for _, entity := range all.EntityList {
		allKeys = append(allKeys, entity.Key)
		for _, sName := range entity.Next {
			sEntity := findEntity(sName, all)
			if sEntity == notExistEntity {
				fmt.Printf("Not Exist Entity: %v(%v): %v\n", entity.Name, entity.CName, sName)
			} else {
				sEntity.p = append(sEntity.p, fmt.Sprintf(`"%v"`, entity.Key))
				entity.n = append(entity.n, fmt.Sprintf(`"%v"`, sEntity.Key))
			}
		}
	}

	buf.WriteString("var (\n")

	buf.writeStringf("allList=[]*Entity{%s}\n", strings.Join(allKeys, ","))

	//var root []string
	buf.WriteString("EntityMap=map[string]*Entity{\n")
	for _, entity := range all.EntityList {
		//if len(entity.p) == -1 {
		//	root = append(root, entity.Key)
		//}
		buf.writeStringf(`"%v":%v,`, entity.Key, entity.Key)
	}
	buf.WriteString("}\n")

	templateStr := `Key:"%v",
		Name:"%v",
		CName:"%v",
		P: []string{%v},
		N: []string{%v},
	`
	for _, entity := range all.EntityList {
		buf.writeStringf("%v=&Entity{\n", entity.Key)
		buf.writeStringf(templateStr, entity.Key, entity.Name, entity.CName, strings.Join(entity.p, ","), strings.Join(entity.n, ","))
		buf.WriteString("}\n")
	}
	buf.WriteString(")\n")
}
